---
tags:
  - МоиЛекции
  - ЯзыкПрограммирования
  - Python
  - QA
---
Разработчики создают программы, которые рано или поздно становятся очень масштабными (если смотреть на количество строчек кода). А с этим приходит и большая ответственность за качество разработанной программы.

Любая серьезная программа, какой бы она ни была краткой, когда-нибудь вырастет и станет очень объёмной. Поэтому разработчики всегда стараюсь разделять программу на различные классы, функции и подпрограммы (ввод/обработка/вывод). Иногда ошибка в коде может быть скрыта настолько глубоко, что её просто так не обнаружишь. И в таком случае единственный способ вывести ее на свет — протестировать код.

Для проверки вместе с функциями и классами нужно написать тесты для кода. Тестирование доказывает, что код работает так, как положено, для любых разновидностей входных данных, которые он может получать.

Тесты позволят быть уверенными в том, что код будет работать правильно и тогда, когда вашими программами начнут пользоваться другие люди. Тестирование при добавлении нового кода гарантирует, что внесенные изменения не изменят текущее поведение программы. 

## unittest – Фреймворк модульного тестирования

Все программисты допускают ошибки, поэтому каждый программист должен часто тестировать свой код и выявлять ошибки до того, как с ними столкнутся другие пользователи. Для этих целей в языке Python существует `unittest`.

```python
import unittest
```

Он поддерживает автоматизацию тестирования, совместное использование кода настройки и завершения для тестов, агрегацию тестов в коллекции и независимость тестов от фреймворка отчетности.

Для достижения этого `unittest` поддерживаются некоторые важные концепции объектно-ориентированным способом:

- **испытательное приспособление**. Тестовая [[Фикстура|фикстура]] представляет собой подготовку, необходимую для выполнения одного или нескольких тестов, и любые связанные с этим действия по очистке. Это может включать, например, создание временных или прокси-баз данных, каталогов или запуск серверного процесса.
- **тестовый случай**. Тестовый случай — это отдельная единица тестирования. Он проверяет определенный ответ на определенный набор входных данных. `unittest` предоставляет базовый класс, `TestCase` который может использоваться для создания новых тестовых случаев.
- **набор тестов**. Тестовый набор — это набор тестовых случаев, тестовых наборов или и того, и другого. Он используется для объединения тестов, которые должны выполняться вместе.
- **участник испытаний**. Тестовый раннер — это компонент, который организует выполнение тестов и предоставляет результат пользователю. Раннер может использовать графический интерфейс, текстовый интерфейс или возвращать специальное значение для указания результатов выполнения тестов.

## Пример использования unittest

Модуль `unittest` предоставляет богатый набор инструментов для построения и запуска тестов. Этот раздел демонстрирует, что небольшого подмножества инструментов достаточно для удовлетворения потребностей большинства пользователей.

Вот короткий скрипт для проверки трех строковых методов:

```python
import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO') # Выполняет 'foo'.upper() и сравнивает результат

    def test_isupper(self):
        self.assertTrue('FOO'.isupper()) # Вернула ли 'FOO'.isupper() true?
        self.assertFalse('Foo'.isupper()) # Вернула ли 'FOO'.isupper() false?

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
```

Тестовый случай создается путем наследования класса `unittest.TestCase`. Три отдельных теста определяются методами, имена которых начинаются со слова `test`. Это соглашение об именовании информирует тестировщика о том, какие методы представляют тесты.

Суть каждого теста — вызов `assertEqual()` для проверки ожидаемого результата; `assertTrue()` или `assertFalse()` для проверки условия; или `assertRaises()` для проверки того, что возникло определенное исключение. Эти методы используются вместо оператора `assert`, чтобы исполнитель теста мог аккумулировать все результаты теста и создать отчет, иначе программа будет постоянно прерываться, что не очень удобно в автоматизации.

Методы `setUp()` и `tearDown()` позволяют определять инструкции, которые будут выполняться до и после каждого метода теста. Они более подробно рассматриваются позже .

Последний блок показывает простой способ запуска тестов. `unittest.main()` предоставляет интерфейс командной строки для тестового скрипта. При запуске из командной строки указанный выше скрипт выдает вывод, который выглядит следующим образом:

```
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
```

Приведенные выше примеры показывают наиболее часто используемые `unittest` функции, которых достаточно для удовлетворения многих повседневных потребностей тестирования. Если хотите изучить полный набор функций, то обратитесь к [документации](https://docs.python.org/3/library/unittest.html).

---
## Практическое задание

![[Задание. Создание первых тестов]]

---
## Ссылки

1. [[Изучаем_Python_Программирование.pdf#page=222&selection=2,0,2,12|Изучаем_Python_Программирование, страница 222]]
2. [unittest — Unit testing framework — Python 3.12.6 documentation](https://docs.python.org/3/library/unittest.html)

---

| [[Тестирование функций при помощи unittest\|Следующая лекция]] |
| ------------------------------------------ |
