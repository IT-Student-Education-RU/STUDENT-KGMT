---
tags:
  - МоиЛекции
  - ЯзыкПрограммирования
  - Python
  - QA
---
Чтобы потренироваться в тестировании, нам потребуется код. Создадим программу и назовем ее `name_function.py`. Ниже представлена простая функция, которая *принимает имя и фамилию* и *возвращает отформатированное полное имя*:

```python
def get_formatted_name(first, last): 
    """Форматирует полное имя.""" 
    full_name = f"{first} {last}" 
    return full_name.title()
```

Функция `get_formatted_name()` объединяет имя и фамилию, разделяя их пробелом, приводит первую букву каждого слова к верхнему регистру и возвращает результат. Чтобы убедиться, что функция работает правильно, создадим программу, которая ее использует. Назовем эту программу `names.py`. Она будет запрашивать у пользователя имя и фамилию и выводить отформатированное полное имя:

```python
from name_function import get_formatted_name 

print("Введите 'q' для выхода из программы.") 
while True: 
    first = input("\nВведите имя: ") 
    if first.lower() == 'q': 
        break 
    last = input("Введите фамилию: ")
    if last.lower() == 'q': 
        break
        
    formatted_name = get_formatted_name(first, last) 
    print(f"\tПолное имя: {formatted_name}.")
```

Программа импортирует функцию `get_formatted_name()` из модуля `name_function.py`. Пользователь вводит имя и фамилию, а программа выводит отформатированное полное имя:

```less
Введите 'q' для выхода из программы.

Введите имя: janis 
Введите фамилию: joplin 
    Полное имя: Janis Joplin. 

Введите имя: bob 
Введите фамилию: dylan 
    Полное имя: Bob Dylan.
    
Введите имя: q
```

*Как видно из примера, программа корректно форматирует имена.*

Теперь предположим, что вы хотите изменить функцию `get_formatted_name()`, чтобы она также могла работать с вторыми именами. При этом важно сохранить корректную работу функции для имен, состоящих только из имени и фамилии. Конечно, можно протестировать изменения, вручную запуская программу `names.py` и вводя имена, но это может быть утомительно и неэффективно.

К счастью, Python предоставляет эффективные средства для автоматизации тестирования функций. С помощью автоматизированных тестов вы сможете убедиться, что функция `get_formatted_name()` работает правильно для всех типов имен, предусмотренных тестами.

### Модульные тесты и тестовые сценарии 

Модуль `unittest` из стандартной библиотеки Python предоставляет функциональность для тестирования вашего кода. *Модульный тест* проверяет правильность работы одного конкретного аспекта поведения функции.

> Тестовый сценарий представляет собой совокупность модульных тестов, которые совместно доказывают, что функция ведет себя так, как положено, во всем диапазоне ситуаций, которые она должна обрабатывать. 

Хороший тестовый сценарий учитывает все возможные виды ввода, которые может получать функция, и включает тесты для представления всех таких ситуаций. Тестовый сценарий с полным покрытием включает полный спектр модульных тестов, покрывающих все возможные варианты использования функции. Обеспечение полного покрытия для крупного проекта может быть весьма непростой задачей. 

Часто бывает достаточно написать модульные тесты для критичных аспектов поведения вашего кода, а затем стремиться к полному покрытию только в том случае, если проект перейдет в фазу масштабного использования.

### Прохождение теста 

Вы не сразу привыкнете к синтаксису создания тестовых сценариев, но после того, как тестовый сценарий будет создан, вы сможете легко добавить новые модульные тесты для своих функций. Чтобы написать тестовый сценарий для функции, импортируйте модуль `unittest` и функцию, которую необходимо протестировать. Затем создайте класс, наследующий от unittest.TestCase, и напишите серию методов для тестирования различных аспектов поведения своей функции. 

Ниже приведен тестовый сценарий с одним методом, который проверяет, что функция `get_formatted_name()` правильно работает при передаче имени и фамилии:

```python
import unittest from name_function 
import get_formatted_name 

❶ class NamesTestCase(unittest.TestCase): 
"""Тесты для 'name_function.py'.""" 

	def test_first_last_name(self): 
		"""Имена вида 'Janis Joplin' работают правильно?""" 
		❷ formatted_name = get_formatted_name('janis', 'joplin') 
		❸ self.assertEqual(formatted_name, 'Janis Joplin') 

❹ if __name__ == '__main__': unittest.main()
```

Сначала мы импортируем `unittest` и тестируемую функцию `get_formatted_name()`. В точке ❶ создается класс `NamesTestCase`, который содержит серию модульных тестов для `get_formatted_name()`. Имя класса выбирается произвольно, но лучше выбрать имя, связанное с функцией, которую вы собираетесь тестировать, и включить в имя класса слово `Test`. Этот класс должен наследовать от класса `unittest`. `TestCase`, чтобы Python знал, как запустить написанные вами тесты. 

Класс `NamesTestCase` содержит один метод, который тестирует всего один аспект `get_formatted_name()` — правильность форматирования имен, состоящих только из имени и фамилии. Мы назвали этот метод `test_first_last_name()`. Любой метод, имя которого начинается с` test_`, будет выполняться автоматически при запуске `test_name_function py`. В тестовом методе вызывается тестируемая функция и сохраняется возвращаемое значение, которое необходимо проверить. В данном примере вызывается функция `get_formatted_name()` с аргументами `'janis'` и `'joplin'`, а результат сохраняется в переменной `formatted_name` ❷.

В точке ❸ используется одна из самых полезных особенностей `unittest`: метод `assert`. Методы `assert` проверяют, что полученный результат соответствует тому результату, который вы рассчитывали получить. 

В данном случае известно, что функция `get_formatted_name()` должна вернуть полное имя с пробелами и капитализацией слов, поэтому переменная `formatted_name` должна содержать  текст `«Janis Joplin»`. Чтобы убедиться в этом, мы используем метод `assertEqual()` из модуля `unittest` и передаем ему переменную `formatted_name` и строку `'Janis Joplin'`. Вызов

```python
self.assertEqual(formatted_name, 'Janis Joplin')
```

означает: «Сравни значение `formatted_name` со строкой `'Janis Joplin'`. Если они равны, как и ожидалось, — хорошо. Но если они не равны, обязательно сообщи мне!»

Мы запустим этот файл напрямую, но важно заметить, что многие тестовые фреймворки импортируют ваши тестовые файлы перед их выполнением. При импортировании файла интерпретатор выполняет файл в процессе импортирования. Блок if в точке ❹ проверяет специальную переменную `__name__`, значение которой задается при выполнении программы. Если файл выполняется как главная программа, то переменной `__name__` будет присвоено значение `'__main__'`. В этом случае вызывается метод `unittest.main()`, который выполняет тестовый сценарий. Если файл импортируется тестовым сценарием, то переменная `__name__` будет содержать значение `'__main__'`, и этот блок выполняться не будет.

При запуске `test_name_function.py` будет получен следующий результат:

```python
. 
---------------------------------------------------------------------- 
Ran 1 test in 0.000s 
OK
```

Точка в первой строке вывода сообщает, что один тест прошел успешно. Следующая строка говорит, что для выполнения одного теста Python потребовалось менее 0,001 секунды. Наконец, завершающее сообщение `OK` говорит о том, что прошли все модульные тесты в тестовом сценарии.

Этот результат показывает, что функция `get_formatted_name()` успешно работает для полных имен, состоящих из имени и фамилии, если только функция не была изменена. В случае внесения изменений в `get_formatted_name()` тест можно запустить снова. И если тестовый сценарий снова пройдет, мы будем знать, что функция продолжает успешно работать с полными именами из двух компонентов.

### Сбой теста 

*Как выглядит сбойный тест?* Попробуем изменить функцию `get_formatted_name()`, чтобы она работала со вторыми именами, но сделаем это так, чтобы она перестала работать с полными именами из двух компонентов. 

Новая версия `get_formatted_name()` с дополнительным аргументом второго имени выглядит так: 

```python
def get_formatted_name(first, middle, last): 
	"""Строит отформатированное полное имя.""" 
	full_name = f"{first} {middle} {last}" 
	return full_name.title()
```

Эта версия должна работать для полных имен из трех компонентов, но тестирование показывает, что она перестала работать для полных имен из двух компонентов. На этот раз файл `test_name_function.py` выдает следующий результат: 

```less
❶ E 
====================================================================== 
❷ ERROR: test_first_last_name (__main__.NamesTestCase) 
---------------------------------------------------------------------- 
❸ Traceback (most recent call last):
	File "test_name_function.py", line 8, in test_first_last_name 
		formatted_name = get_formatted_name('janis', 'joplin') 
	TypeError: get_formatted_name() missing 1 required positional argument: 
			'last' 
---------------------------------------------------------------------- 
❹ Ran 1 test in 0.000s 
❺ FAILED (errors=1)
``` 

Теперь информации гораздо больше, потому что при сбое теста разработчик должен знать, почему это произошло. Вывод начинается с одной буквы `E` ❶, которая сообщает, что один модульный тест в тестовом сценарии привел к ошибке. 

Затем мы видим, что ошибка произошла в тесте `test_first_last_name()` в `NamesTestCase` ❷. Конкретная информация о сбойном тесте особенно важна в том случае, если тестовый сценарий состоит из нескольких модульных тестов.

В точке ❸ — стандартная трассировка, из которой видно, что вызов функции `get_formatted_name('janis', 'joplin')` перестал работать из-за необходимого позиционного аргумента. 

Также из вывода следует, что был выполнен один модульный тест ❹. 

Наконец, дополнительное сообщение информирует, что тестовый сценарий в целом не прошел и в ходе выполнения произошла одна ошибка при выполнении тестового сценария ❺. Эта информация размещается в конце вывода, чтобы она была видна сразу; разработчику не придется прокручивать длинный протокол, чтобы узнать количество сбойных тестов.

### Реакция на сбойный тест 

*Что делать, если тест не проходит?* Если предположить, что проверяются правильные условия, прохождение теста означает, что функция работает правильно, а сбой — что в новом коде добавилась ошибка. Итак, если тест не прошел, изменять нужно не тест, а код, который привел к сбою теста. 

> Проанализируйте изменения, внесенные в функцию, и разберитесь, как они привели к нарушению ожидаемого поведения. 

В данном случае у функции `get_formatted_name()` было всего два обязательных параметра: **имя** и **фамилия**. Теперь она требует три обязательных параметра: **имя**, **второе имя** и **фамилию**. Добавление обязательного параметра для второго имени нарушило ожидаемое поведение `get_formatted_name()`. В таком случае лучше всего сделать параметр второго имени необязательным. После этого тесты для имен с двумя компонентами снова будут проходить, и программа сможет получать также вторые имена.

Изменим функцию `get_formatted_name()`, чтобы параметр второго имени перестал быть обязательным, и снова выполним тестовый сценарий. Если он пройдет, можно переходить к проверке правильности обработки вторых имен. 

Чтобы сделать второе имя необязательным, нужно переместить параметр `middle` в конец списка параметров в определении функции и задать ему пустое значение по умолчанию. Также будет добавлена проверка **if**, которая правильно строит полное имя в зависимости от того, передается второе имя или нет:

```python
def get_formatted_name(first, last, middle=''): 
	"""Строит отформатированное полное имя.""" 
	if middle: 
		full_name = f"{first} {middle} {last}" 
	else: 
		full_name = f"{first} {last}" 
return full_name.title()
```

В новой версии `get_formatted_name()` параметр `middle` необязателен. Если второе имя передается функции, то полное имя будет содержать имя, второе имя и фамилию. В противном случае полное имя состоит только из имени и фамилии. Теперь функция должна работать для обеих разновидностей имен. Чтобы узнать, работает ли функция для имен из двух компонентов, снова запустите `test_name_function.py`:

```less
. 
---------------------------------------------------------------------- 
Ran 1 test in 0.000s 
OK
```

Теперь тестовый сценарий проходит. Такой исход идеален; он означает, что функция снова работает для имен из двух компонентов и нам не придется тестировать функцию вручную. Исправить ошибку было несложно, потому что сбойный тест помог выявить новый код, нарушивший существующее поведение.

### Добавление новых тестов 

Теперь мы знаем, что `get_formatted_name()` работает для простых имен, и можем написать второй тест для имен из трех компонентов. Для этого в класс `NamesTestCase` добавляется еще один метод:

```python
... 
class NamesTestCase(unittest.TestCase): 
	"""Тесты для 'name_function.py'.""" 
	
	def test_first_last_name(self): 
... 

def test_first_last_middle_name(self): 
	"""Работают ли такие имена, как 'Wolfgang Amadeus Mozart'?""" 
	❶ formatted_name = get_formatted_name( 
		'wolfgang', 'mozart', 'amadeus') 
	self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart') 
	
	if __name__ == '__main__': 
		unittest.main()
```

Новому методу присваивается имя `test_first_last_middle_name()`. Имя метода должно начинаться с `test_`, чтобы этот метод выполнялся автоматически при запуске `test_name_functio.py`. В остальном имя выбирается так, чтобы оно четко показывало, какое именно поведение `get_formatted_name()` мы тестируем. В результате при сбое теста вы сразу видите, к каким именам он относится. 

Не нужно опасаться длинных имен методов в классах `TestCase`: **имена должны быть содержательными, чтобы донести информацию до разработчика в случае сбоя**, а поскольку Python вызывает их автоматически, вам никогда не придется вручную вводить эти имена при вызове. 

Чтобы протестировать функцию, мы вызываем `get_formatted_name()` c тремя компонентами ❶, после чего используем `assertEqual()` для проверки того, что возвращенное полное имя совпадает с ожидаемым. При повторном запуске `test_ name_function.py` оба теста проходят успешно:

```less
.. 
---------------------------------------------------------------------- 
Ran 2 tests in 0.000s 
OK
```

Отлично! Теперь мы знаем, что функция по-прежнему работает с именами из двух компонентов, как `Janis Joplin`, но можем быть уверены в том, что она сработает и для имен с тремя компонентами, такими как `Wolfgang Amadeus Mozart`.

---
## Практическое задание

![[Задание. Тестирование функции. Город, страна]]

---
## Ссылки

1. [[Изучаем_Python_Программирование.pdf#page=222&selection=2,0,2,12|Изучаем_Python_Программирование, страница 222]]

---

| [[Тестирование в Python. Что такое unittest\|Предыдущая лекция]] | [[Тестирование классов\|Следующая лекция]] |
| ---------------------------------------------------------------- | ------------------------------------------ |
